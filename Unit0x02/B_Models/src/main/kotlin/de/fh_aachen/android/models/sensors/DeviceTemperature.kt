// (C) 2025 A.Vo√ü, a.voss@fh-aachen.de, info@codebasedlearning.dev

package de.fh_aachen.android.models.sensors

import android.util.Log
import androidx.lifecycle.ViewModel
import de.fh_aachen.android.models.ModelsApplication
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch

private val deviceTemperatureRange: ClosedRange<Int> = 50..70

/*
Note that 'State' in 'Flow' refers to a current value (state) that
can change over time.
'State' with composables is observable by the UI and triggers
recomposition on change.
*/

class DeviceTemperatureRepository(private val simulationScope: CoroutineScope): SensorFlows {
    // this is a common pattern to protect mutable state from being modified outside of this class;
    // note that the interface contains just StateFlows
    private val _rawValue = MutableStateFlow(deviceTemperatureRange.center())
    override val rawValue: StateFlow<Int> get() = _rawValue

    private val _bias = MutableStateFlow(0)
    override val bias: StateFlow<Int> get() = _bias

    private val _calibratedValue = MutableStateFlow(_rawValue.value)
    override val calibratedValue: StateFlow<Int> get() = _calibratedValue

    init {
        startUpdating()
    }

    private fun startUpdating() {
        // Update calibrated value whenever rawValue or bias changes
        simulationScope.launch {
            // combine returns a Flow whose values are generated by combining the most recently
            // emitted values by each flow. This new value is emitted.
            combine(_rawValue, _bias) { raw, bias -> raw + bias }
                .collect { combinedValue ->
                    _calibratedValue.value = combinedValue
                    Log.i(SENSOR_TAG,"new device temperature value: ${calibratedValue.value} (${rawValue.value};${bias.value})")
                }
        }

        // simulate sensor updates
        simulationScope.launch {
            while (true) {
                // here it is not emit but setting the new value
                _rawValue.value = _rawValue.value.nextJitter(withinRange = deviceTemperatureRange)
                delay(1000L)
            }
        }
    }

    override fun calibrate(newBias: Int) {
        _bias.value = newBias
    }
}

// The ViewModel is more or less the repo. Only calibration is performed
// with increments, not absolut.

class DeviceTemperatureViewModel : ViewModel() {
    private val repository = ModelsApplication.serviceLocator.deviceTemperatureRepository

    // "hot" flows, but not activated until someone listens to them, e.g. with collectAsState
    val calibratedValue: StateFlow<Int> = repository.calibratedValue
    val bias: StateFlow<Int> = repository.bias

    fun calibrate(incBias: Int) {
        repository.calibrate(repository.bias.value + incBias)
    }
}
